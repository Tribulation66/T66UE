// Copyright Tribulation 66. All Rights Reserved.

#include "UI/Style/T66Style.h"
#include "T66.h"

#include "Engine/Texture2D.h"
#include "HAL/IConsoleManager.h"
#include "Misc/Paths.h"
#include "Styling/CoreStyle.h"
#include "Styling/SlateStyleRegistry.h"
#include "Styling/SlateTypes.h"
#include "Brushes/SlateRoundedBoxBrush.h"
#include "Brushes/SlateColorBrush.h"
#include "Widgets/Layout/SBox.h"
#include "Layout/Visibility.h"
#include "Widgets/Input/SButton.h"
#include "Widgets/Input/SComboButton.h"
#include "Widgets/Text/STextBlock.h"
#include "Fonts/CompositeFont.h"
#include "Blueprint/UserWidget.h"
#include "TimerManager.h"

TSharedPtr<FSlateStyleSet> FT66Style::StyleInstance;

// --- Colors (defaults = Dark palette; SetTheme() overwrites at runtime) ---
FLinearColor FT66Style::Tokens::Bg(0.08f, 0.08f, 0.10f, 1.0f);
FLinearColor FT66Style::Tokens::Panel(0.0f, 0.0f, 0.0f, 1.0f);
FLinearColor FT66Style::Tokens::Panel2(0.0f, 0.0f, 0.0f, 1.0f);
FLinearColor FT66Style::Tokens::Stroke(0.18f, 0.18f, 0.20f, 1.0f);
FLinearColor FT66Style::Tokens::Scrim(0.f, 0.f, 0.f, 0.70f);
FLinearColor FT66Style::Tokens::Text(1.0f, 1.0f, 1.0f, 1.0f);
FLinearColor FT66Style::Tokens::TextMuted(0.75f, 0.75f, 0.75f, 1.0f);
FLinearColor FT66Style::Tokens::Accent(0.0f, 0.0f, 0.0f, 1.0f);
FLinearColor FT66Style::Tokens::Accent2(0.0f, 0.0f, 0.0f, 1.0f);
FLinearColor FT66Style::Tokens::Danger(0.95f, 0.15f, 0.15f, 1.0f);
FLinearColor FT66Style::Tokens::Success(0.20f, 0.80f, 0.35f, 1.0f);
FLinearColor FT66Style::Tokens::Border(1.0f, 1.0f, 1.0f, 1.0f);
const FMargin FT66Style::Tokens::ButtonPadding(12.f, 4.f);
const FMargin FT66Style::Tokens::ButtonPaddingPressed(12.f, 5.f, 12.f, 3.f);

namespace
{
	// Keep recent old style sets alive so existing Slate widgets' brush/style
	// raw pointers remain valid until the UI is rebuilt with fresh widgets.
	// Without this, calling StyleInstance.Reset() would free the FButtonStyle and
	// FSlateBrush objects that live Slate widgets still reference, causing access violations.
	// We keep up to 4 old sets to handle rapid theme toggling / font cycling.
	static TArray<TSharedPtr<FSlateStyleSet>> GPreviousStyleSets;
	static constexpr int32 GMaxPreviousStyleSets = 4;

	void RetainOldStyleSet(TSharedPtr<FSlateStyleSet>&& OldSet)
	{
		if (OldSet.IsValid())
		{
			GPreviousStyleSets.Add(MoveTemp(OldSet));
			while (GPreviousStyleSets.Num() > GMaxPreviousStyleSets)
			{
				GPreviousStyleSets.RemoveAt(0);
			}
		}
	}

	// ----- Active UI theme -----
	static ET66UITheme GActiveTheme = ET66UITheme::Dark;

	// Button textures: 6 pre-rendered PNGs (Dark/Light x N/H/P) with bevel, gloss, border baked in.
	// Generated by Scripts/GenerateButtonTextures.py, imported by Scripts/ImportButtonTextures.py.
	// Loaded once and kept alive so FSlateBrush resource pointers remain valid.
	static TObjectPtr<UTexture2D> GBtnDarkN = nullptr;
	static TObjectPtr<UTexture2D> GBtnDarkH = nullptr;
	static TObjectPtr<UTexture2D> GBtnDarkP = nullptr;
	static TObjectPtr<UTexture2D> GBtnLightN = nullptr;
	static TObjectPtr<UTexture2D> GBtnLightH = nullptr;
	static TObjectPtr<UTexture2D> GBtnLightP = nullptr;

	static bool HasButtonTextures()
	{
		return GBtnDarkN && GBtnDarkH && GBtnDarkP && GBtnLightN && GBtnLightH && GBtnLightP;
	}

	static void GetButtonTexturesForTheme(ET66UITheme Theme, UTexture2D*& OutN, UTexture2D*& OutH, UTexture2D*& OutP)
	{
		if (Theme == ET66UITheme::Light)
		{
			OutN = GBtnLightN; OutH = GBtnLightH; OutP = GBtnLightP;
		}
		else
		{
			OutN = GBtnDarkN; OutH = GBtnDarkH; OutP = GBtnDarkP;
		}
	}

	static FSlateBrush MakeButtonTextureBrush(UTexture2D* Tex)
	{
		FSlateBrush Brush;
		Brush.DrawAs = ESlateBrushDrawType::Image;
		Brush.Tiling = ESlateBrushTileType::NoTile;
		Brush.SetResourceObject(Tex);
		Brush.TintColor = FSlateColor(FLinearColor::White);  // texture has final colors baked in
		Brush.ImageSize = FVector2D(512.f, 128.f);
		return Brush;
	}

	static void LoadButtonTexturesOnce()
	{
		// Only load once — textures persist for the lifetime of the process.
		if (GBtnDarkN) return;
		auto Load = [](const TCHAR* Path) -> UTexture2D* {
			UTexture2D* T = LoadObject<UTexture2D>(nullptr, Path);
			UE_LOG(LogTemp, Log, TEXT("[T66Style] Load button tex %s -> %s"), Path, T ? TEXT("OK") : TEXT("MISS"));
			return T;
		};
		GBtnDarkN  = Load(TEXT("/Game/UI/Assets/ButtonDark_N.ButtonDark_N"));
		GBtnDarkH  = Load(TEXT("/Game/UI/Assets/ButtonDark_H.ButtonDark_H"));
		GBtnDarkP  = Load(TEXT("/Game/UI/Assets/ButtonDark_P.ButtonDark_P"));
		GBtnLightN = Load(TEXT("/Game/UI/Assets/ButtonLight_N.ButtonLight_N"));
		GBtnLightH = Load(TEXT("/Game/UI/Assets/ButtonLight_H.ButtonLight_H"));
		GBtnLightP = Load(TEXT("/Game/UI/Assets/ButtonLight_P.ButtonLight_P"));
	}

	// Panel textures: 2 pre-rendered PNGs (Dark + Light) with bevel, gloss, border baked in.
	// Generated by Scripts/GeneratePanelTextures.py, imported by Scripts/ImportPanelTextures.py.
	// 9-slice (Box draw type) so corners stay crisp at any panel size.
	static TObjectPtr<UTexture2D> GPanelDark = nullptr;
	static TObjectPtr<UTexture2D> GPanelLight = nullptr;

	static bool GPanelTexturesAvailable()
	{
		return GPanelDark && GPanelLight;
	}

	static UTexture2D* GetPanelTextureForTheme(ET66UITheme Theme)
	{
		return (Theme == ET66UITheme::Light) ? GPanelLight.Get() : GPanelDark.Get();
	}

	static FSlateBrush MakePanelTextureBrush(UTexture2D* Tex)
	{
		FSlateBrush Brush;
		Brush.DrawAs = ESlateBrushDrawType::Box;   // 9-slice: corners preserved, center stretches
		Brush.Tiling = ESlateBrushTileType::NoTile;
		Brush.SetResourceObject(Tex);
		Brush.TintColor = FSlateColor(FLinearColor::White);
		Brush.ImageSize = FVector2D(128.f, 128.f);
		// Margin defines the 9-slice inset as fraction of image size.
		// 0.25 = 25% from each edge = 32px on a 128px texture, covering the corner/border region.
		Brush.Margin = FMargin(0.25f);
		return Brush;
	}

	static void LoadPanelTexturesOnce()
	{
		if (GPanelDark) return;
		auto Load = [](const TCHAR* Path) -> UTexture2D* {
			UTexture2D* T = LoadObject<UTexture2D>(nullptr, Path);
			UE_LOG(LogTemp, Log, TEXT("[T66Style] Load panel tex %s -> %s"), Path, T ? TEXT("OK") : TEXT("MISS"));
			return T;
		};
		GPanelDark  = Load(TEXT("/Game/UI/Assets/PanelDark.PanelDark"));
		GPanelLight = Load(TEXT("/Game/UI/Assets/PanelLight.PanelLight"));
	}

	/** Overwrite Tokens:: colors with the palette for the given theme. */
	void ApplyThemePalette(ET66UITheme Theme)
	{
		using T = FT66Style::Tokens;
		if (Theme == ET66UITheme::Light)
		{
		// Light: grey panels, black text, dark borders
		T::Bg          = FLinearColor(0.70f, 0.70f, 0.73f, 1.0f);
		T::Panel       = FLinearColor(0.45f, 0.45f, 0.48f, 1.0f);
		T::Panel2      = FLinearColor(0.45f, 0.45f, 0.48f, 1.0f);
		T::Stroke      = FLinearColor(0.35f, 0.35f, 0.38f, 1.0f);
		T::Scrim       = FLinearColor(0.60f, 0.60f, 0.60f, 0.70f);
		T::Text        = FLinearColor(0.0f, 0.0f, 0.0f, 1.0f);
		T::TextMuted   = FLinearColor(0.2f, 0.2f, 0.2f, 1.0f);
			T::Accent      = FLinearColor(0.45f, 0.45f, 0.48f, 1.0f);
			T::Accent2     = FLinearColor(0.45f, 0.45f, 0.48f, 1.0f);
			T::Danger      = FLinearColor(0.95f, 0.15f, 0.15f, 1.0f);
			T::Success     = FLinearColor(0.20f, 0.80f, 0.35f, 1.0f);
			T::Border      = FLinearColor(0.15f, 0.15f, 0.15f, 1.0f);
		}
	else // Dark (default)
	{
		// Dark: pitch black panels, white text, white borders
		T::Bg          = FLinearColor(0.08f, 0.08f, 0.10f, 1.0f);
		T::Panel       = FLinearColor(0.0f, 0.0f, 0.0f, 1.0f);
		T::Panel2      = FLinearColor(0.0f, 0.0f, 0.0f, 1.0f);
		T::Stroke      = FLinearColor(0.18f, 0.18f, 0.20f, 1.0f);
		T::Scrim       = FLinearColor(0.0f, 0.0f, 0.0f, 0.70f);
		T::Text        = FLinearColor(1.0f, 1.0f, 1.0f, 1.0f);
		T::TextMuted   = FLinearColor(0.75f, 0.75f, 0.75f, 1.0f);
		T::Accent      = FLinearColor(0.0f, 0.0f, 0.0f, 1.0f);
		T::Accent2     = FLinearColor(0.0f, 0.0f, 0.0f, 1.0f);
		T::Danger      = FLinearColor(0.95f, 0.15f, 0.15f, 1.0f);
		T::Success     = FLinearColor(0.20f, 0.80f, 0.35f, 1.0f);
		T::Border      = FLinearColor(1.0f, 1.0f, 1.0f, 1.0f);
	}
	}

	// ----- Font options: 0=Caesar Dressing, 1=Cinzel, 2=Cormorant SC, 3=Germania One, 4=Grenze, 5=Alagard -----
	static int32 GThemeFontIndex = 5;  // Alagard (default); cycle with T66NextFont console command
	static bool GForceBoldFont = false; // When true, use bold variant for all text (T66Bold console command)

	static const TCHAR* GThemeFontPaths[] = {
		TEXT("New Fonts/Caesar_Dressing/CaesarDressing-Regular.ttf"),   // 0 Caesar Dressing
		TEXT("New Fonts/Cinzel/static/Cinzel-Regular.ttf"),             // 1 Cinzel
		TEXT("New Fonts/Cormorant_SC/CormorantSC-Regular.ttf"),         // 2 Cormorant SC
		TEXT("New Fonts/Germania_One/GermaniaOne-Regular.ttf"),         // 3 Germania One
		TEXT("New Fonts/Grenze/Grenze-Regular.ttf"),                    // 4 Grenze
		TEXT("New Fonts/Alagard/alagard.ttf"),                         // 5 Alagard
	};
	// Bold variant per font (nullptr = no bold asset, use Regular). Caesar Dressing, Germania One, Alagard have no bold.
	static const TCHAR* GThemeFontPathsBold[] = {
		nullptr,                                                       // 0 Caesar Dressing
		TEXT("New Fonts/Cinzel/static/Cinzel-Bold.ttf"),               // 1 Cinzel
		TEXT("New Fonts/Cormorant_SC/CormorantSC-Bold.ttf"),            // 2 Cormorant SC
		nullptr,                                                       // 3 Germania One
		TEXT("New Fonts/Grenze/Grenze-Bold.ttf"),                      // 4 Grenze
		nullptr,                                                       // 5 Alagard
	};
	static const int32 GThemeFontCount = UE_ARRAY_COUNT(GThemeFontPaths);

	const FString& FontsDir()
	{
		static const FString Dir = FPaths::ProjectContentDir() / TEXT("Slate/Fonts");
		return Dir;
	}

	// Single TTF from Content/Slate/Fonts (path relative to FontsDir).
	FSlateFontInfo MakeFontFromFile(const TCHAR* RelativePath, int32 Size)
	{
		const FString Path = FontsDir() / RelativePath;
		if (!FPaths::FileExists(Path))
			return FCoreStyle::GetDefaultFontStyle(TEXT("Regular"), Size);
		TSharedPtr<const FCompositeFont> CompositeFont = MakeShared<FStandaloneCompositeFont>(
			NAME_None, Path, EFontHinting::Default, EFontLoadingPolicy::LazyLoad);
		return FSlateFontInfo(CompositeFont, static_cast<float>(Size));
	}

	// All UI font tokens use the selected font from GThemeFontPaths. Bold uses GThemeFontPathsBold when available.
	FSlateFontInfo ThemeFont(const TCHAR* Weight, int32 Size)
	{
		const int32 Idx = FMath::Clamp(GThemeFontIndex, 0, GThemeFontCount - 1);
		const bool bWantBold = GForceBoldFont || (FCString::Stricmp(Weight, TEXT("Bold")) == 0);
		const TCHAR* Path = GThemeFontPaths[Idx];
		if (bWantBold && GThemeFontPathsBold[Idx] != nullptr)
		{
			const FString BoldPath = FontsDir() / GThemeFontPathsBold[Idx];
			if (FPaths::FileExists(BoldPath))
				Path = GThemeFontPathsBold[Idx];
		}
		return MakeFontFromFile(Path, Size);
	}

	int32 AdvanceToNextFontIndex()
	{
		GThemeFontIndex = (GThemeFontIndex + 1) % GThemeFontCount;
		return GThemeFontIndex;
	}

	void ToggleForceBoldFont()
	{
		GForceBoldFont = !GForceBoldFont;
	}
}

// --- Font theme (all text uses GFontTheme in this file) ---
FSlateFontInfo FT66Style::Tokens::FontRegular(int32 Size)
{
	return ThemeFont(TEXT("Regular"), Size);
}
FSlateFontInfo FT66Style::Tokens::FontBold(int32 Size)
{
	return ThemeFont(TEXT("Bold"), Size);
}
FSlateFontInfo FT66Style::Tokens::FontTitle()
{
	return ThemeFont(TEXT("Bold"), 52);
}
FSlateFontInfo FT66Style::Tokens::FontHeading()
{
	return ThemeFont(TEXT("Bold"), 24);
}
FSlateFontInfo FT66Style::Tokens::FontBody()
{
	return ThemeFont(TEXT("Regular"), 14);
}
FSlateFontInfo FT66Style::Tokens::FontSmall()
{
	return ThemeFont(TEXT("Regular"), 11);
}
FSlateFontInfo FT66Style::Tokens::FontChip()
{
	return ThemeFont(TEXT("Bold"), 11);
}
FSlateFontInfo FT66Style::Tokens::FontButton()
{
	return ThemeFont(TEXT("Bold"), 16);
}

void FT66Style::CycleToNextFont()
{
	AdvanceToNextFontIndex();
	if (StyleInstance.IsValid())
	{
		FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
		RetainOldStyleSet(MoveTemp(StyleInstance));
	}
	Initialize();
}

void FT66Style::ToggleBoldFont()
{
	ToggleForceBoldFont();
	if (StyleInstance.IsValid())
	{
		FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
		RetainOldStyleSet(MoveTemp(StyleInstance));
	}
	Initialize();
}

ET66UITheme FT66Style::GetTheme()
{
	return GActiveTheme;
}

void FT66Style::SetTheme(ET66UITheme NewTheme)
{
	// Early-out: skip all work if the theme hasn't actually changed.
	if (NewTheme == GActiveTheme && StyleInstance.IsValid())
	{
		return;
	}

	GActiveTheme = NewTheme;
	ApplyThemePalette(NewTheme);

	// Re-initialize the style set so new brushes/button styles use updated tokens.
	// Keep old sets alive so existing widgets' raw pointers stay valid.
	if (StyleInstance.IsValid())
	{
		FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
		RetainOldStyleSet(MoveTemp(StyleInstance));
	}
	// Note: button textures are NOT cleared here — they are loaded once and reused across themes.
	Initialize();
}

FName FT66Style::GetStyleSetName()
{
	static const FName Name(TEXT("T66Style"));
	return Name;
}

const ISlateStyle& FT66Style::Get()
{
	if (!StyleInstance.IsValid())
	{
		Initialize();
	}
	check(StyleInstance.IsValid());
	return *StyleInstance;
}

void FT66Style::Initialize()
{
	if (StyleInstance.IsValid())
	{
		return;
	}

	StyleInstance = MakeShared<FSlateStyleSet>(GetStyleSetName());

	// Load button textures once (6 pre-rendered PNGs with bevel/gloss/border baked in).
	LoadButtonTexturesOnce();
	// Load panel textures once (2 pre-rendered PNGs, 9-slice for arbitrary panel sizes).
	LoadPanelTexturesOnce();

	bool bUseButtonTextures = HasButtonTextures();
	UTexture2D* BtnN = nullptr; UTexture2D* BtnH = nullptr; UTexture2D* BtnP = nullptr;
	if (bUseButtonTextures)
	{
		GetButtonTexturesForTheme(GActiveTheme, BtnN, BtnH, BtnP);
	}

	bool bUsePanelTextures = GPanelTexturesAvailable();
	UTexture2D* PanelTex = bUsePanelTextures ? GetPanelTextureForTheme(GActiveTheme) : nullptr;

	UE_LOG(LogTemp, Log, TEXT("[T66Style] Resources: ButtonTex=%d  PanelTex=%d  (theme=%d)"),
		bUseButtonTextures ? 1 : 0, bUsePanelTextures ? 1 : 0, static_cast<int32>(GActiveTheme));

	// Panel brushes: prefer texture (9-slice with baked border/bevel), fallback to rounded box
	const float BorderW = Tokens::BorderWidth;
	const FLinearColor BorderColor = Tokens::Border;

	if (bUsePanelTextures && PanelTex)
	{
		// Texture-backed panels: same texture for Bg, Panel, and Panel2 (all same visual treatment).
		// The panel texture has bevel/gloss/border baked in; white tint passes it through.
		FSlateBrush PanelBrush = MakePanelTextureBrush(PanelTex);
		StyleInstance->Set("T66.Brush.Bg",     new FSlateBrush(PanelBrush));
		StyleInstance->Set("T66.Brush.Panel",   new FSlateBrush(PanelBrush));
		StyleInstance->Set("T66.Brush.Panel2",  new FSlateBrush(PanelBrush));
	}
	else
	{
		// Fallback: solid rounded box with border
		StyleInstance->Set("T66.Brush.Bg",     new FSlateRoundedBoxBrush(Tokens::Bg, Tokens::CornerRadius, BorderColor, BorderW));
		StyleInstance->Set("T66.Brush.Panel",   new FSlateRoundedBoxBrush(Tokens::Panel, Tokens::CornerRadius, BorderColor, BorderW));
		StyleInstance->Set("T66.Brush.Panel2",  new FSlateRoundedBoxBrush(Tokens::Panel2, Tokens::CornerRadius, BorderColor, BorderW));
	}

	// Utility brushes (always procedural)
	StyleInstance->Set("T66.Brush.Stroke", new FSlateRoundedBoxBrush(Tokens::Stroke, Tokens::CornerRadiusSmall, BorderColor, BorderW));
	StyleInstance->Set("T66.Brush.Circle", new FSlateRoundedBoxBrush(FLinearColor::White, 110.f, BorderColor, BorderW));
	StyleInstance->Set("T66.Brush.Scrim",  new FSlateRoundedBoxBrush(Tokens::Scrim, 0.f));

	// Text styles
	{
		const FLinearColor Shadow(0.f, 0.f, 0.f, 0.85f);

		FTextBlockStyle Title = FTextBlockStyle()
			.SetFont(Tokens::FontTitle())
			.SetColorAndOpacity(Tokens::Text)
			.SetShadowOffset(FVector2D(1.f, 1.f))
			.SetShadowColorAndOpacity(Shadow);
		StyleInstance->Set("T66.Text.Title", Title);

		FTextBlockStyle Heading = FTextBlockStyle()
			.SetFont(Tokens::FontHeading())
			.SetColorAndOpacity(Tokens::Text)
			.SetShadowOffset(FVector2D(1.f, 1.f))
			.SetShadowColorAndOpacity(Shadow);
		StyleInstance->Set("T66.Text.Heading", Heading);

		FTextBlockStyle Body = FTextBlockStyle()
			.SetFont(Tokens::FontBody())
			.SetColorAndOpacity(Tokens::TextMuted);
		StyleInstance->Set("T66.Text.Body", Body);

		FTextBlockStyle Chip = FTextBlockStyle()
			.SetFont(Tokens::FontChip())
			.SetColorAndOpacity(Tokens::Text);
		StyleInstance->Set("T66.Text.Chip", Chip);

		FTextBlockStyle ButtonText = FTextBlockStyle()
			.SetFont(Tokens::FontButton())
			.SetColorAndOpacity(Tokens::Text);
		StyleInstance->Set("T66.Text.Button", ButtonText);
	}

	// Button styles: prefer 6-texture set (with effects baked in), else solid rounded box fallback
	{
		if (bUseButtonTextures && BtnN && BtnH && BtnP)
		{
			// Pre-rendered textures with bevel/gloss/border baked in. White tint = pass through.
			auto MakeTexStyle = [](UTexture2D* N, UTexture2D* H, UTexture2D* P) {
				return FButtonStyle()
					.SetNormal(MakeButtonTextureBrush(N))
					.SetHovered(MakeButtonTextureBrush(H))
					.SetPressed(MakeButtonTextureBrush(P))
					.SetNormalPadding(FT66Style::Tokens::ButtonPadding)
					.SetPressedPadding(FT66Style::Tokens::ButtonPaddingPressed);
			};
			StyleInstance->Set("T66.Button.Primary",      MakeTexStyle(BtnN, BtnH, BtnP));
			StyleInstance->Set("T66.Button.Neutral",      MakeTexStyle(BtnN, BtnH, BtnP));
			StyleInstance->Set("T66.Button.Danger",       MakeTexStyle(BtnN, BtnH, BtnP));
			StyleInstance->Set("T66.Button.ToggleActive", MakeTexStyle(BtnN, BtnH, BtnP));
		}
		else
		{
			// Fallback: solid rounded box with border (no texture needed)
			const FLinearColor NeutralN = Tokens::Panel2;
			const FLinearColor NeutralH = Tokens::Panel2 + FLinearColor(0.05f, 0.05f, 0.07f, 0.f);
			const FLinearColor NeutralP = Tokens::Panel2 + FLinearColor(0.08f, 0.08f, 0.10f, 0.f);

			auto MakeBoxStyle = [&](const FLinearColor& N, const FLinearColor& H, const FLinearColor& P) {
				return FButtonStyle()
					.SetNormal(FSlateRoundedBoxBrush(N, Tokens::CornerRadiusSmall, BorderColor, BorderW))
					.SetHovered(FSlateRoundedBoxBrush(H, Tokens::CornerRadiusSmall, BorderColor, BorderW))
					.SetPressed(FSlateRoundedBoxBrush(P, Tokens::CornerRadiusSmall, BorderColor, BorderW))
					.SetNormalPadding(Tokens::ButtonPadding)
					.SetPressedPadding(Tokens::ButtonPaddingPressed);
			};
			StyleInstance->Set("T66.Button.Primary",      MakeBoxStyle(NeutralN, NeutralH, NeutralP));
			StyleInstance->Set("T66.Button.Neutral",      MakeBoxStyle(NeutralN, NeutralH, NeutralP));
			StyleInstance->Set("T66.Button.Danger",       MakeBoxStyle(NeutralN, NeutralH, NeutralP));
			// ToggleActive: selected/pressed look — brighter fill + visible border so ON/OFF selection is obvious.
			{
				const FLinearColor ToggleN = Tokens::Text;
				const FLinearColor ToggleH = Tokens::Text * 0.90f + FLinearColor(0,0,0,0.10f);
				const FLinearColor ToggleP = Tokens::Text * 0.75f + FLinearColor(0,0,0,0.25f);
				const float ToggleBorderW = 2.f;
				const FLinearColor ToggleBorder = Tokens::Accent2.A > 0.01f ? Tokens::Accent2 : Tokens::Stroke;
				StyleInstance->Set("T66.Button.ToggleActive", FButtonStyle()
					.SetNormal(FSlateRoundedBoxBrush(ToggleN, Tokens::CornerRadiusSmall, ToggleBorder, ToggleBorderW))
					.SetHovered(FSlateRoundedBoxBrush(ToggleH, Tokens::CornerRadiusSmall, ToggleBorder, ToggleBorderW))
					.SetPressed(FSlateRoundedBoxBrush(ToggleP, Tokens::CornerRadiusSmall, ToggleBorder, ToggleBorderW))
					.SetNormalPadding(Tokens::ButtonPadding)
					.SetPressedPadding(Tokens::ButtonPaddingPressed));
			}
		}

		// Row style: transparent background, very thin border, subtle hover highlight.
		// Used for leaderboard rows and list items that are clickable but shouldn't look like buttons.
		{
			constexpr float RowBorderW = 0.5f;
			const FLinearColor RowBorderColor = Tokens::Stroke;
			const FLinearColor RowN = FLinearColor(0.f, 0.f, 0.f, 0.f);       // transparent
			const FLinearColor RowH = Tokens::Stroke * FLinearColor(1,1,1,0.5f); // subtle highlight
			const FLinearColor RowP = Tokens::Stroke * FLinearColor(1,1,1,0.7f); // slightly stronger on press
			StyleInstance->Set("T66.Button.Row", FButtonStyle()
				.SetNormal(FSlateRoundedBoxBrush(RowN, 2.f, RowBorderColor, RowBorderW))
				.SetHovered(FSlateRoundedBoxBrush(RowH, 2.f, RowBorderColor, RowBorderW))
				.SetPressed(FSlateRoundedBoxBrush(RowP, 2.f, RowBorderColor, RowBorderW))
				.SetNormalPadding(FMargin(0.f))
				.SetPressedPadding(FMargin(0.f)));
		}
	}

	// Dropdown: use exactly the same button style as T66.Button.Neutral (texture or fallback) + small down arrow
	{
		FComboButtonStyle DropdownStyle;
		DropdownStyle.ButtonStyle = StyleInstance->GetWidgetStyle<FButtonStyle>("T66.Button.Neutral");
		FSlateBrush ArrowBrush = FCoreStyle::Get().GetWidgetStyle<FComboButtonStyle>("ComboButton").DownArrowImage;
		ArrowBrush.TintColor = FSlateColor(Tokens::Text);
		DropdownStyle.DownArrowImage = ArrowBrush;
		DropdownStyle.MenuBorderBrush = FSlateRoundedBoxBrush(Tokens::Panel, Tokens::CornerRadiusSmall, BorderColor, BorderW);
		DropdownStyle.MenuBorderPadding = FMargin(0.f);
		StyleInstance->Set("T66.Dropdown.ComboButtonStyle", DropdownStyle);
	}

	FSlateStyleRegistry::RegisterSlateStyle(*StyleInstance);

	static bool bConsoleRegistered = false;
	if (!bConsoleRegistered)
	{
		IConsoleManager::Get().RegisterConsoleCommand(
			TEXT("T66NextFont"),
			TEXT("Cycle to the next UI font (Caesar Dressing, Cinzel, Cormorant SC, Germania One, Grenze). Reopens style so new UI uses it."),
			FConsoleCommandDelegate::CreateStatic(&FT66Style::CycleToNextFont),
			ECVF_Default);
		IConsoleManager::Get().RegisterConsoleCommand(
			TEXT("T66Bold"),
			TEXT("Toggle force-bold: all UI text uses the bold variant of the current font (if the font has a bold asset)."),
			FConsoleCommandDelegate::CreateStatic(&FT66Style::ToggleBoldFont),
			ECVF_Default);
		bConsoleRegistered = true;
	}
}

FOnClicked FT66Style::DebounceClick(const FOnClicked& InnerDelegate)
{
	// Global timestamp shared by ALL debounced buttons.
	// Any click within 150 ms of the previous one is silently dropped.
	// 150 ms is imperceptible for intentional clicks but prevents:
	//   - double-fire from rapid/spam clicking
	//   - UI rebuild crashes from overlapping widget teardowns
	//   - accidental double-navigation
	return FOnClicked::CreateLambda([InnerDelegate]() -> FReply
	{
		static double GLastClickTime = 0.0;
		const double Now = FPlatformTime::Seconds();
		if (Now - GLastClickTime < 0.15)
		{
			return FReply::Handled();
		}
		GLastClickTime = Now;
		return InnerDelegate.Execute();
	});
}

// ---------------------------------------------------------------------------
// Full params-based MakeButton — every button in the game funnels through here.
// ---------------------------------------------------------------------------
TSharedRef<SWidget> FT66Style::MakeButton(const FT66ButtonParams& Params)
{
	// 1. Resolve ButtonStyle name and default background color from Type.
	FName StyleName;
	FLinearColor DefaultBtnColor;
	switch (Params.Type)
	{
	case ET66ButtonType::Primary:
		StyleName = "T66.Button.Primary";    DefaultBtnColor = Tokens::Accent2; break;
	case ET66ButtonType::Danger:
		StyleName = "T66.Button.Danger";     DefaultBtnColor = Tokens::Danger;  break;
	case ET66ButtonType::Success:
		StyleName = "T66.Button.Primary";    DefaultBtnColor = Tokens::Success; break;
	case ET66ButtonType::ToggleActive:
		StyleName = "T66.Button.ToggleActive"; DefaultBtnColor = Tokens::Text;  break;
	case ET66ButtonType::Row:
		StyleName = "T66.Button.Row";        DefaultBtnColor = FLinearColor::Transparent; break;
	default: // Neutral
		StyleName = "T66.Button.Neutral";    DefaultBtnColor = Tokens::Panel2;  break;
	}

	const FButtonStyle& BtnStyle = Get().GetWidgetStyle<FButtonStyle>(StyleName);
	const FTextBlockStyle& TxtStyle = Get().GetWidgetStyle<FTextBlockStyle>("T66.Text.Button");

	// 2. Debounce the click delegate.
	FOnClicked SafeClick = DebounceClick(Params.OnClicked);

	// 3. Button background color.
	//    When a color override is set (e.g. ON/OFF toggle selected state), use it so the
	//    selected button is visually distinct. Otherwise with textures use white so the
	//    baked-in border/gloss passes through; with fallback use the style default.
	TAttribute<FSlateColor> BtnColor;
	if (Params.bHasColorOverride)
	{
		BtnColor = Params.ColorOverride;
	}
	else if (HasButtonTextures())
	{
		BtnColor = TAttribute<FSlateColor>(FSlateColor(FLinearColor::White));
	}
	else
	{
		BtnColor = TAttribute<FSlateColor>(FSlateColor(DefaultBtnColor));
	}

	// 4. Content padding (negative sentinel = don't override, use FMargin(0)).
	const FMargin ContentPad = (Params.Padding.Left >= 0.f) ? Params.Padding : FMargin(0.f);

	// 5. Build the inner content widget (text block or custom).
	TAttribute<FText> TextAttr = Params.DynamicLabel.IsBound()
		? Params.DynamicLabel
		: TAttribute<FText>(Params.Label);

	FSlateFontInfo TextFont = (Params.FontSize > 0)
		? Tokens::FontBold(Params.FontSize)
		: TxtStyle.Font;

	TAttribute<FSlateColor> TextColor = Params.bHasTextColorOverride
		? Params.TextColorOverride
		: TAttribute<FSlateColor>(TxtStyle.ColorAndOpacity);

	TSharedRef<SWidget> Content = Params.CustomContent.IsValid()
		? Params.CustomContent.ToSharedRef()
		: StaticCastSharedRef<SWidget>(
			SNew(STextBlock)
			.Text(TextAttr)
			.Font(TextFont)
			.ColorAndOpacity(TextColor)
			.Justification(ETextJustify::Center)
		);

	// 6. Assemble: SBox > SButton > Content.
	//    Width/Height of 0 means "no constraint" (FOptionalSize() = unset).
	//    Row buttons use HAlign_Fill so custom content (e.g. column layouts) stretches to full width.
	const EHorizontalAlignment BtnHAlign = (Params.Type == ET66ButtonType::Row) ? HAlign_Fill : HAlign_Center;
	const EVerticalAlignment BtnVAlign = (Params.Type == ET66ButtonType::Row) ? VAlign_Fill : VAlign_Center;

	return SNew(SBox)
		.MinDesiredWidth(Params.MinWidth > 0.f ? Params.MinWidth : FOptionalSize())
		.HeightOverride(Params.Height > 0.f ? Params.Height : FOptionalSize())
		.Visibility(Params.Visibility)
		[
			SNew(SButton)
			.HAlign(BtnHAlign)
			.VAlign(BtnVAlign)
			.OnClicked(SafeClick)
			.ButtonStyle(&BtnStyle)
			.ButtonColorAndOpacity(BtnColor)
			.ContentPadding(ContentPad)
			.IsEnabled(Params.IsEnabled)
			[
				Content
			]
		];
}

// ---------------------------------------------------------------------------
// Convenience overload — thin wrapper around the params version.
// ---------------------------------------------------------------------------
TSharedRef<SWidget> FT66Style::MakeButton(
	const FText& Label,
	FOnClicked OnClicked,
	ET66ButtonType Type,
	float MinWidth)
{
	FT66ButtonParams P(Label, MoveTemp(OnClicked), Type);
	P.MinWidth = MinWidth;
	return MakeButton(P);
}

// ---------------------------------------------------------------------------
// HasPanelTextures — public query so callers can check texture availability.
// ---------------------------------------------------------------------------
bool FT66Style::HasPanelTextures()
{
	return GPanelTexturesAvailable();
}

// ---------------------------------------------------------------------------
// Full params-based MakePanel — every panel in the game funnels through here.
// ---------------------------------------------------------------------------
TSharedRef<SWidget> FT66Style::MakePanel(
	const TSharedRef<SWidget>& Content,
	const FT66PanelParams& Params,
	TSharedPtr<SBorder>* OutBorder)
{
	// 1. Resolve brush name from panel type.
	FName BrushName;
	switch (Params.Type)
	{
	case ET66PanelType::Bg:     BrushName = "T66.Brush.Bg";     break;
	case ET66PanelType::Panel2: BrushName = "T66.Brush.Panel2"; break;
	default:                    BrushName = "T66.Brush.Panel";   break;
	}

	// 2. Background color: when textures are loaded, use white tint to pass through
	//    the baked-in look. Color overrides only apply to the fallback path.
	TAttribute<FSlateColor> BgColor;
	if (HasPanelTextures())
	{
		BgColor = TAttribute<FSlateColor>(FSlateColor(FLinearColor::White));
	}
	else if (Params.bHasColorOverride)
	{
		BgColor = Params.ColorOverride;
	}
	else
	{
		// Fallback: match the procedural brush tint to the token color.
		FLinearColor DefaultColor;
		switch (Params.Type)
		{
		case ET66PanelType::Bg:     DefaultColor = Tokens::Bg;     break;
		case ET66PanelType::Panel2: DefaultColor = Tokens::Panel2; break;
		default:                    DefaultColor = Tokens::Panel;   break;
		}
		BgColor = TAttribute<FSlateColor>(FSlateColor(DefaultColor));
	}

	// 3. Build the SBorder.
	TSharedRef<SBorder> Border = SNew(SBorder)
		.BorderImage(Get().GetBrush(BrushName))
		.BorderBackgroundColor(BgColor)
		.Padding(Params.Padding)
		.Visibility(Params.Visibility)
		[
			Content
		];

	if (OutBorder)
	{
		*OutBorder = Border;
	}

	return Border;
}

// ---------------------------------------------------------------------------
// Convenience overload — panel type + padding only.
// ---------------------------------------------------------------------------
TSharedRef<SWidget> FT66Style::MakePanel(
	const TSharedRef<SWidget>& Content,
	ET66PanelType Type,
	FMargin Padding)
{
	return MakePanel(Content, FT66PanelParams(Type).SetPadding(Padding));
}

// ---------------------------------------------------------------------------
// GetDropdownComboButtonStyle — theme-aware combo style for dropdowns.
// ---------------------------------------------------------------------------
const FComboButtonStyle& FT66Style::GetDropdownComboButtonStyle()
{
	return Get().GetWidgetStyle<FComboButtonStyle>("T66.Dropdown.ComboButtonStyle");
}

// ---------------------------------------------------------------------------
// MakeDropdown — themed SComboButton (Dark = black bg + white text, Light = light bg + black text).
// ---------------------------------------------------------------------------
TSharedRef<SWidget> FT66Style::MakeDropdown(const FT66DropdownParams& Params)
{
	const FComboButtonStyle& ComboStyle = GetDropdownComboButtonStyle();
	TSharedRef<SComboButton> Combo = SNew(SComboButton)
		.ComboButtonStyle(&ComboStyle)
		.OnGetMenuContent_Lambda([OnGet = Params.OnGetMenuContent]() { return OnGet(); })
		.ContentPadding(Params.Padding)
		.ButtonContent()
		[
			Params.Content
		];

	// Height 0 = no override: let the combo button size to its content so dropdowns aren't clipped.
	return SNew(SBox)
		.MinDesiredWidth(Params.MinWidth > 0.f ? Params.MinWidth : FOptionalSize())
		.HeightOverride(Params.Height > 0.f ? Params.Height : FOptionalSize())
		.Visibility(Params.Visibility)
		[
			Combo
		];
}

// ---------------------------------------------------------------------------
// DeferRebuild — safe, next-tick widget rebuild for any UUserWidget.
// ---------------------------------------------------------------------------
void FT66Style::DeferRebuild(UUserWidget* Widget, int32 ZOrder)
{
	if (!Widget) return;
	UWorld* World = Widget->GetWorld();
	if (!World) return;

	TWeakObjectPtr<UUserWidget> Weak(Widget);
	World->GetTimerManager().SetTimerForNextTick(
		FTimerDelegate::CreateLambda([Weak, ZOrder]()
		{
			UUserWidget* W = Weak.Get();
			if (!W || !W->GetCachedWidget().IsValid()) return;

			const bool bInViewport = W->IsInViewport();
			if (bInViewport) W->RemoveFromParent();

			W->ReleaseSlateResources(true);
			W->TakeWidget();

			if (bInViewport) W->AddToViewport(ZOrder);
		}));
}

void FT66Style::Shutdown()
{
	if (!StyleInstance.IsValid())
	{
		return;
	}

	FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
	StyleInstance.Reset();
}

